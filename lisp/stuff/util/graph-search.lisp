(defun follow (edge)
  (declare (special *reachedp* *get-possible-directions-fn* *current-path*))
  (let ((*current-path* (cons edge *current-path*)))
    (declare (special *current-path*))
    (if (funcall *reachedp*)
        *current-path*
        (try-paths (funcall *get-possible-directions-fn*)))))

(defun try-paths (edges)
  (when edges
    (or (follow (car edges))
        (try-paths (cdr edges)))))

(labels ((origin (edge)
           (car edge))
         (terminus (edge)
           (cdr edge)))
 (let ((*edges* '((a . b)
                  (a . c)
                  (a . d)
                  (b . a)
                  (b . d)
                  (c . a)
                  (c . d)
                  (c . e)
                  (d . a)
                  (d . b)
                  (d . c)
                  (d . e)
                  (e . c)
                  (e . d))))
   (declare (special *edges*))
   (let* ((*reachedp* #'(lambda ()
                          (declare (special *current-path*))
                          (or (eql 'e (origin (first *current-path*)))
                              (member 'e *current-path* :key #'cdr))))
          (*get-possible-directions-fn* #'(lambda ()
                                            (declare (special *edges*))
                                            (remove-if (lambda (edge)
                                                         (declare (special *current-path*))
                                                         (member (terminus edge)
                                                                 *current-path*
                                                                 :key #'origin))
                                                       (remove (terminus (first *current-path*)) *edges*
                                                               :key #'origin
                                                               :test-not #'eql))))
          (*current-path* nil))
     (declare (special *current-path* *reachedp* *get-possible-directions-fn*))
     (cdr (reverse (follow '(nil . a)))))))
